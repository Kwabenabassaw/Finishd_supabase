-- ============================================================================
-- V3 Migration 4/10: Communities
-- ============================================================================

-- ── Communities ──────────────────────────────────────────────────────────────

CREATE TABLE public.communities (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  show_id           INT UNIQUE NOT NULL,
  title             TEXT NOT NULL,
  poster_path       TEXT,
  media_type        TEXT REFERENCES public.media_types(value),
  member_count      INT DEFAULT 0,
  post_count        INT DEFAULT 0,
  last_activity_at  TIMESTAMPTZ DEFAULT now(),
  created_at        TIMESTAMPTZ DEFAULT now(),
  created_by        UUID REFERENCES auth.users(id)
);

ALTER TABLE public.communities ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read communities"   ON public.communities FOR SELECT USING (true);
CREATE POLICY "Auth create communities"   ON public.communities FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Update community counters" ON public.communities FOR UPDATE USING (true);

-- ── Community Members ───────────────────────────────────────────────────────

CREATE TABLE public.community_members (
  community_id  BIGINT NOT NULL REFERENCES public.communities(id) ON DELETE CASCADE,
  user_id       UUID   NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role          TEXT   DEFAULT 'member' REFERENCES public.community_roles(value),
  joined_at     TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (community_id, user_id)
);

CREATE INDEX idx_community_members_user ON public.community_members(user_id);

ALTER TABLE public.community_members ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read members"  ON public.community_members FOR SELECT USING (true);
CREATE POLICY "Auth join communities" ON public.community_members FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users leave communities" ON public.community_members FOR DELETE USING (auth.uid() = user_id);

-- ── Community Posts ─────────────────────────────────────────────────────────

CREATE TABLE public.community_posts (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  community_id      BIGINT REFERENCES public.communities(id) ON DELETE CASCADE,
  show_id           INT,
  author_id         UUID REFERENCES auth.users(id),
  content           TEXT,
  media_urls        TEXT[],
  media_types       TEXT[],
  hashtags          TEXT[],
  is_spoiler        BOOLEAN DEFAULT false,
  is_hidden         BOOLEAN DEFAULT false,
  score             INT DEFAULT 0,
  upvotes           INT DEFAULT 0,
  downvotes         INT DEFAULT 0,
  comment_count     INT DEFAULT 0,
  view_count        INT DEFAULT 0,
  deleted_at        TIMESTAMPTZ,                      -- Soft delete
  created_at        TIMESTAMPTZ DEFAULT now(),
  updated_at        TIMESTAMPTZ DEFAULT now(),
  last_activity_at  TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_posts_community_created ON public.community_posts(community_id, created_at DESC);
CREATE INDEX idx_posts_author            ON public.community_posts(author_id);
CREATE INDEX idx_posts_score             ON public.community_posts(score DESC);

CREATE TRIGGER handle_posts_updated_at
  BEFORE UPDATE ON public.community_posts FOR EACH ROW EXECUTE PROCEDURE extensions.moddatetime(updated_at);

ALTER TABLE public.community_posts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read posts"  ON public.community_posts FOR SELECT USING (deleted_at IS NULL);
CREATE POLICY "Auth create posts"  ON public.community_posts FOR INSERT WITH CHECK (auth.uid() = author_id);
CREATE POLICY "Users update posts" ON public.community_posts FOR UPDATE USING (auth.uid() = author_id);

-- ── Community Comments (Threaded) ───────────────────────────────────────────

CREATE TABLE public.community_comments (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id     UUID NOT NULL REFERENCES public.community_posts(id) ON DELETE CASCADE,
  author_id   UUID REFERENCES auth.users(id),
  content     TEXT,
  parent_id   UUID REFERENCES public.community_comments(id),
  upvotes     INT DEFAULT 0,
  downvotes   INT DEFAULT 0,
  is_hidden   BOOLEAN DEFAULT false,
  deleted_at  TIMESTAMPTZ,                            -- Soft delete
  created_at  TIMESTAMPTZ DEFAULT now(),
  updated_at  TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_comments_post_created   ON public.community_comments(post_id, created_at DESC);
CREATE INDEX idx_comments_parent         ON public.community_comments(parent_id) WHERE parent_id IS NOT NULL;
CREATE INDEX idx_comments_author         ON public.community_comments(author_id);

CREATE TRIGGER handle_comments_updated_at
  BEFORE UPDATE ON public.community_comments FOR EACH ROW EXECUTE PROCEDURE extensions.moddatetime(updated_at);

ALTER TABLE public.community_comments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read comments"  ON public.community_comments FOR SELECT USING (deleted_at IS NULL);
CREATE POLICY "Auth create comments"  ON public.community_comments FOR INSERT WITH CHECK (auth.uid() = author_id);

-- ── Post Votes ──────────────────────────────────────────────────────────────

CREATE TABLE public.post_votes (
  user_id     UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  post_id     UUID NOT NULL REFERENCES public.community_posts(id) ON DELETE CASCADE,
  vote        INT NOT NULL CHECK (vote IN (1, -1)),
  created_at  TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (user_id, post_id)
);

ALTER TABLE public.post_votes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read post_votes"    ON public.post_votes FOR SELECT USING (true);
CREATE POLICY "Users vote on posts"       ON public.post_votes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users change post votes"   ON public.post_votes FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users remove post votes"   ON public.post_votes FOR DELETE USING (auth.uid() = user_id);

-- ── Comment Votes ───────────────────────────────────────────────────────────

CREATE TABLE public.comment_votes (
  user_id     UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  comment_id  UUID NOT NULL REFERENCES public.community_comments(id) ON DELETE CASCADE,
  vote        INT NOT NULL CHECK (vote IN (1, -1)),
  created_at  TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (user_id, comment_id)
);

ALTER TABLE public.comment_votes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read comment_votes"    ON public.comment_votes FOR SELECT USING (true);
CREATE POLICY "Users vote on comments"       ON public.comment_votes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users change comment votes"   ON public.comment_votes FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users remove comment votes"   ON public.comment_votes FOR DELETE USING (auth.uid() = user_id);

-- ── Community Functions ─────────────────────────────────────────────────────

CREATE OR REPLACE FUNCTION public.join_community(p_show_id BIGINT)
RETURNS VOID AS $$
DECLARE v_uid UUID; v_comm_id BIGINT;
BEGIN
  v_uid := auth.uid();
  SELECT id INTO v_comm_id FROM public.communities WHERE show_id = p_show_id;
  INSERT INTO public.community_members (community_id, user_id) VALUES (v_comm_id, v_uid) ON CONFLICT DO NOTHING;
  IF FOUND THEN
    UPDATE public.communities SET member_count = member_count + 1 WHERE id = v_comm_id;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.leave_community(p_show_id BIGINT)
RETURNS VOID AS $$
DECLARE v_uid UUID; v_comm_id BIGINT;
BEGIN
  v_uid := auth.uid();
  SELECT id INTO v_comm_id FROM public.communities WHERE show_id = p_show_id;
  DELETE FROM public.community_members WHERE community_id = v_comm_id AND user_id = v_uid;
  IF FOUND THEN
    UPDATE public.communities SET member_count = member_count - 1 WHERE id = v_comm_id;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ── Comment Count Trigger ───────────────────────────────────────────────────

CREATE OR REPLACE FUNCTION public.handle_community_comment_count()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.community_posts SET comment_count = comment_count + 1 WHERE id = NEW.post_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.community_posts SET comment_count = comment_count - 1 WHERE id = OLD.post_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_community_comment_change
  AFTER INSERT OR DELETE ON public.community_comments
  FOR EACH ROW EXECUTE FUNCTION public.handle_community_comment_count();

-- ── Vote Function ───────────────────────────────────────────────────────────

CREATE OR REPLACE FUNCTION public.vote_on_post(p_post_id UUID, p_vote INT)
RETURNS VOID AS $$
DECLARE
  v_uid UUID; v_current INT; v_new INT;
  v_up_d INT := 0; v_down_d INT := 0;
BEGIN
  v_uid := auth.uid();
  SELECT vote INTO v_current FROM public.post_votes WHERE user_id = v_uid AND post_id = p_post_id;
  IF v_current IS NULL THEN v_current := 0; END IF;
  v_new := CASE WHEN p_vote = v_current THEN 0 ELSE p_vote END;
  IF v_new = v_current THEN RETURN; END IF;
  IF v_current =  1 THEN v_up_d   := v_up_d   - 1; END IF;
  IF v_current = -1 THEN v_down_d := v_down_d - 1; END IF;
  IF v_new     =  1 THEN v_up_d   := v_up_d   + 1; END IF;
  IF v_new     = -1 THEN v_down_d := v_down_d + 1; END IF;
  IF v_new = 0 THEN
    DELETE FROM public.post_votes WHERE user_id = v_uid AND post_id = p_post_id;
  ELSE
    INSERT INTO public.post_votes (user_id, post_id, vote) VALUES (v_uid, p_post_id, v_new)
    ON CONFLICT (user_id, post_id) DO UPDATE SET vote = v_new, created_at = now();
  END IF;
  UPDATE public.community_posts SET
    upvotes = upvotes + v_up_d, downvotes = downvotes + v_down_d,
    score = score + (v_up_d - v_down_d), last_activity_at = now()
  WHERE id = p_post_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
